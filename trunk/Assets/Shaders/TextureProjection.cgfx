
float3 gEyePosition;
float3 gBlockPosition;

float2 tex_scale = {0.5f,0.5f};

texture ProjTexture1;
texture ProjTexture2;
texture ProjTexture3;
sampler2D ProjSampler1 = sampler_state
{
    Texture = <diffuseTexture1>;
    MinFilter = LinearMipMapNearest;
    MagFilter = Linear;
};
sampler2D ProjSampler2 = sampler_state
{
    Texture = <diffuseTexture2>;
    MinFilter = LinearMipMapNearest;
    MagFilter = Linear;
};
sampler2D ProjSampler3 = sampler_state
{
    Texture = <diffuseTexture3>;
    MinFilter = LinearMipMapNearest;
    MagFilter = Linear;
};

void VertexProg(float4 position : POSITION,
                float3 normal   : NORMAL,

                out float4 oPosition : POSITION,
                out float3 objectPos : TEXCOORD0,
                out float3 oNormal   : TEXCOORD1
               )
{
	oPosition = mul(glstate.matrix.mvp, position);
	objectPos = position.xyz;
	oNormal = normal;
}

void FragmentProg(	float4 position  : TEXCOORD0,
                    float3 normal    : TEXCOORD1,
                    
					out float4 color     : COLOR,
					
					uniform float3 eyePosition,
					uniform float3 blockPosition
					)
{
	//Lighting
	float3 P = position.xyz;
	float3 N = normalize(normal);

	float4 ambient = glstate.lightmodel.ambient;

	float3 L = normalize(mul(float3x3(glstate.matrix.inverse.modelview[0]),glstate.light[0].position.xyz));
	float diffuseLight = max(dot(L, N), 0);
	float4 diffuse = glstate.light[0].diffuse * diffuseLight;

	float3 V = normalize(eyePosition - P);
	float3 H = normalize(L + V);
	float specularLight = pow(max(dot(H, N), 0), glstate.material.shininess);
	if (diffuseLight <= 0) specularLight = 0;
	float4 specular = glstate.light[0].specular * specularLight;
	
	//Texture
	float3 blend_weights = abs(N.xyz);
	blend_weights = (blend_weights - 0.2) * 7;
	blend_weights = max(blend_weights, 0);
	blend_weights /= (blend_weights.x + blend_weights.y + blend_weights.z ).xxx;
	
	float4 blended_color;
	float2 coord1 = P.yz * tex_scale;
	float2 coord2 = P.zx * tex_scale;
	float2 coord3 = P.xy * tex_scale;
	
	float4 col1 = tex2D(ProjSampler1, coord1);
	float4 col2 = tex2D(ProjSampler2, coord2);
	float4 col3 = tex2D(ProjSampler3, coord3);
	
	blended_color = col1.xyzw * blend_weights.xxxx +
					col2.xyzw * blend_weights.yyyy +
					col3.xyzw * blend_weights.zzzz;
	
	//Combine
	color = (ambient) + (blended_color * diffuseLight) + specular;
	color.w = 1;
}

technique t0
{
	pass p0
	{
        VertexProgram = compile arbvp1 VertexProg();
        FragmentProgram = compile arbfp1 FragmentProg( gEyePosition, gBlockPosition );

        DepthTestEnable = true;
		DepthMask = true;        
	}
}